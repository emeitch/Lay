<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>lay prototype</title>
<link rel="stylesheet" href="./base.css">
<link rel="stylesheet" href="./index.css">
<script src="maquette.min.js"></script>
<script>
var jsonObject = {
  TodoMVC: {
    domain: {
      Task: {
        _proto: "Entity",
        title: "string",
        completed: "bool"
      },
      tasks: {
        _stuff: [
          {
            _proto: "Task",
            title: "buy a milk",
            completed: false,
          },
          {
            _proto: "Task",
            title: "buy a coffee",
            completed: false,
          },
          {
            _proto: "Task",
            title: "buy a tea",
            completed: true,
          }
        ]
      }
    },
    presentation: {
      _proto: "DOM::Document",
      body: {
        _proto: "Body",
        _stuff: [
          {
            _proto: "Section",
            class: "todoapp",
            _stuff: [
              {
                _proto: "Div",
                _stuff: [
                  {
                    _proto: "Header",
                    class: "header",
                    _stuff: [
                      {
                        _proto: "H1",
                        _stuff: [
                          "todos"
                        ]
                      },
                      {
                        _proto: "Input",
                        class: "new-todo",
                        placeholder: "What needs to be done?"
                      }
                    ]
                  },
                  {
                    _proto: "Section",
                    class: "main",
                    _stuff: [
                      {
                        _proto: "Input",
                        class: "toggle-all",
                        type: "checkbox"
                      },
                      {
                        _proto: "Ul",
                        class: "todo-list",
                        _stuff: [
                          {
                            _proto: "domain.tasks.map",
                            _stuff: [
                              {
                                _proto: "Lambda",
                                task: "Task",
                                _stuff: [
                                  {
                                    _proto: "Li",
                                    _stuff: [
                                      {
                                        _proto: "Div",
                                        class: "view",
                                        _stuff: [
                                          {
                                            _proto: "Input",
                                            class: "toggle",
                                            type: "checkbox",
                                          },
                                          {
                                            _proto: "Label",
                                            _stuff: [
                                              {
                                                _proto: "Ref",
                                                _path: "task.title"
                                              }
                                            ]
                                          },
                                          {
                                            _proto: "Button",
                                            class: "destroy",
                                          }
                                        ]
                                      },
                                      {
                                        _proto: "Input",
                                        class: "edit",
                                        value: {
                                          _proto: "Ref",
                                          _path: "task.title"
                                        }
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    _proto: "Footer",
                    class: "footer",
                    _stuff: [
                      {
                        _proto: "Span",
                        class: "todo-count",
                        _stuff: [
                          {
                            _proto: "Strong",
                            _stuff: "1"
                          },
                          {
                            _proto: "Span",
                          },
                          {
                            _proto: "Span",
                            _stuff: "item"
                          },
                          {
                            _proto: "Span",
                            _stuff: " left"
                          }
                        ]
                      },
                      {
                        _proto: "Ul",
                        class: "filters",
                        _stuff: [
                          {
                            _proto: "Li",
                            _stuff: [
                              {
                                _proto: "A",
                                href: "#/",
                                class: "selected",
                                _stuff: "All"
                              }
                            ]
                          },
                          {
                            _proto: "Span",
                          },
                          {
                            _proto: "Li",
                            _stuff: [
                              {
                                _proto: "A",
                                href: "#/active",
                                _stuff: "Active"
                              }
                            ]
                          },
                          {
                            _proto: "Span",
                          },
                          {
                            _proto: "Li",
                            _stuff: [
                              {
                                _proto: "A",
                                href: "#/completed",
                                _stuff: "Completed"
                              }
                            ]
                          },
                        ]
                      },
                      {
                        _proto: "Button",
                        class: "clear-completed",
                        _stuff: "Clear Completed"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            _proto: "Footer",
            class: "info",
            _stuff: [
              {
                _proto: "P",
                _stuff: "Double-click to edit a todo"
              },
              {
                _proto: "P",
                _stuff: [
                  "Created by ",
                  {
                    _proto: "A",
                    href: "http://github.com/emeitch/",
                    _stuff: "Hideyuki MORITA (emeitch)"
                  }
                ]
              },
              {
                _proto: "P",
                _stuff: [
                  "Part of ",
                  {
                    _proto: "A",
                    href: "http://todomvc.com",
                    _stuff: "TodoMVC"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  }
}

function flatten(array) {
  return Array.prototype.concat.apply([], array);
}

const PRIMITIVETYPES = [
  "number",
  "string",
  "boolean"
];

const HTMLTAGS = [
  "Body",
  "Section",
  "Footer",
  "Header",
  "P",
  "Ul",
  "Li",
  "Input",
  "Button",
  "Div",
  "Span",
  "H1",
  "Label",
  "Strong",
  "A",
]

function box(src={}) {
  const type = typeof(src);
  if (PRIMITIVETYPES.includes(type)) {
    return new Primitive(src);
  }
  
  if (src._proto === "Ref") {
    return new Ref(src);
  }
  
  if (src._proto === "Lambda") {
    return new Lambda(src);
  }
  
  if (HTMLTAGS.includes(src._proto)) {
    return new DOM(src);
  }
  
  if (src._proto === "Entity") {
    return new Entity(src);
  }
  
  return new Box(src);
}

class Stuff {
  constructor(items=[]) {
    this.items = items;
  }
  
  get one() {
    return this.items[0];
  }
    
  clone() {
    let clone = new this.constructor([]);
    clone.items = this.items.map(c => c.clone());
    return clone;
  }
  
  eval(context) {
    let result = this.clone();
    result.items = this.items.map(c => c.eval(context))
    return result.flatten();
  }
  
  flatten() {
    const flatten = this.clone();
    flatten.items = this.items.reduce((a, item) => {
      if (item instanceof Stuff) {
        return a.concat(item.items);
      } else {
        return a.concat([item]);
      }
    }, []);
    return flatten;
  }
  
  map(f) {
    const result = new Stuff(this.items.map(f));
    return result;
  }
}

class Box {
  constructor(src) {
    this.protoPath = "Box"
    this.stuff = new Stuff();
    
    // todo Map Boxを動的に生成しているが、本当はstaticに設定したい
    // 静的に配備しようとすると、MapがBoxを継承している関係上、無限ループとなる。
    // Box/Stuff/Mapを抽象化するクラスを定義し、無限ループにならないようにしたい
    const b = this;
    this.props = new (class {
      get map() {
        const m = new Map({});
        m.target = b;
        return m;
      }
    });
    Object.getOwnPropertyNames(src)
    .forEach(k => {
      const v = src[k]
      if (k === "_proto") {
        this.protoPath = v;
      } else if (k === "_stuff") {
        const items = Array.isArray(v) ? v : [v];
        this.stuff = new Stuff(items.map(i => box(i)));
      } else {
        this.props[k] = box(v);
      }
    });
  }
    
  clone() {
    let c = new this.constructor({});
    c.protoPath = this.protoPath;
    c.stuff = this.stuff.clone();
    this.keys.forEach(n => {
      c.props[n] = this.props[n].clone();
    });
    return c;
  }
  
  proto(context) {
    return this.ref(this.protoPath, context);
  }
  
  get keys() {
    return Object.getOwnPropertyNames(this.props)
  }
    
  eval(context=[]) {
    const proto = this.proto(context);
    return proto.apply(this, context);
  }
  
  apply(args, context) {
    let result = args.clone();
    
    context = context.slice() // duplication
    context.push(result);
    
    result.keys.forEach(n => {
      result.props[n] = result.props[n].eval(context);
    });
    
    result.stuff = result.stuff.eval(context);
    return result;
  }
  
  ref(path, context) {
    const keys = path.split(".");
    
    if (this.props[keys[0]]) {
      return keys.reduce((b, s) => b.props[s], this);      
    }
    
    context = context.slice(); // duplication
    const parent = context.pop(); // with side-effects for context
    if (parent) {
      return parent.ref(path, context);
    }
    
    return box(); // todo ダミーBoxを返している状況なので変更する
  }
    
  get map() {
  }
}

class Map extends Box {
  apply(argbox, context) {
    const block = argbox.stuff.one;
    const barg = block.keys[0]; // todo key値の型と一致するか確認
    return this.target.stuff.map(item => {
      // todo stuffにMapボックスが存在すると無限ループになるのをうまく解決 / そもそもstuffがMapボックスになる状況のセマンティクスとは何か?
      const b = block.clone();
      b.props[barg] = item;
      return b.eval(context);
    });
  }
}

class Primitive extends Box {
  constructor(src) {
    super({
      _proto: "Primitive",
    });
    this.value = src
  }
  
  clone() {
    const c = super.clone();
    c.value = this.value;
    return c;
  }
}

class Entity extends Box {
}

class RefProto extends Box {
  apply(argbox, context) {
    const b = argbox.ref(argbox.path, context);
    return b.eval(context);
  }
}
const REFPROTO = new RefProto({});

class Ref extends Box {
  constructor(src) {
    super(src);
    this.path = src._path
  }
  
  clone() {
    const c = super.clone();
    c.path = this.path;
    return c;
  }

  proto(context) {
    return REFPROTO;
  }
    
  // todo おそらくもう不要
  // value() {
  //   return this.ref(this.props.path).value();
  // }
}

class LambdaProto extends Box {
  apply(argbox, context) {
    // argbox内のブロック引数を参照できるようにするために
    // argboxをコンテキストに追加し
    // itemのみをevalした結果を返し簡約する
    context = context.slice() // duplication
    context.push(argbox);
    const item = argbox.stuff.one;
    return item.eval(context);
  }
}
const LAMBDAPROTO = new LambdaProto({});
class Lambda extends Box {
  proto(context) {
    return LAMBDAPROTO;
  }
}

class DOM extends Box {
  constructor(src) {
    super(src);
    this.tag = src._proto;
  }
  
  clone() {
    const c = super.clone();
    c.tag = this.tag;
    return c;
  }

  render() {
    const attrs = this.keys.reduce((r, n) => Object.assign(r, {[n]: this.props[n].value}), {});
    const children = flatten(this.stuff.items.map(b => {
      if (b.value) {
        return b.value;
      }
      
      if (b.render) {
        return b.render();
      }
      
      return [];
    }));
    return [maquette.h(
      this.tag,
      attrs,
      children
    )];
  }
}

function vdom(src) { 
  const app = src.eval();
  console.log(app);
  return app.props.presentation.props.body.render()[0];
}

const src = box(jsonObject).props.TodoMVC;

// Initializes the projector 
var projector = maquette.createProjector();
window.document.addEventListener('DOMContentLoaded', function () {
   projector.replace(window.document.body, () => vdom(src));
});

</script>
</head>
<body>
</body>
</html>