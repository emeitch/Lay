<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>lay prototype</title>
<link rel="stylesheet" href="./base.css">
<link rel="stylesheet" href="./index.css">
<script src="maquette.min.js"></script>
<script>
var jsonObject = {
  TodoMVC: {
    domain: {
      Task: {
        _symbol: "Entity",
        title: "string",
        completed: "bool"
      },
      tasks: {
        _on: {
          create: {
            title: "string",
            _stuff: {
              _symbol: "Chain",
              _stuff: [
                { _symbol: "self" },
                { _symbol: "append",
                  _stuff: {
                    _symbol: "Task",
                    title: { _symbol: "title" },
                    completed: false
                  }
                }
              ]
            }
          }
        },
        _stuff: [
        ]
      }
    },
    presentation: {
      body: {
        _symbol: "Body",
        _stuff: [
          {
            _symbol: "Section",
            class: "todoapp",
            _stuff: [
              {
                _symbol: "Div",
                _stuff: [
                  {
                    _symbol: "Header",
                    class: "header",
                    _stuff: [
                      {
                        _symbol: "H1",
                        _stuff: [
                          "todos"
                        ]
                      },
                      {
                        _symbol: "Input",
                        class: "new-todo",
                        placeholder: "What needs to be done?",
                        _relay: {
                          keyup: {
                            _stuff: {
                              _symbol: "Chain",
                              _stuff: [
                                { _symbol: "domain" },
                                { _symbol: "tasks" },
                                { _symbol: "create",
                                  title: {
                                    _symbol: "value"
                                  }
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  },
                  {
                    _symbol: "Section",
                    class: "main",
                    _stuff: [
                      {
                        _symbol: "Input",
                        class: "toggle-all",
                        type: "checkbox"
                      },
                      {
                        _symbol: "Ul",
                        class: "todo-list",
                        _stuff: {
                          _symbol: "Chain",
                          _stuff: [
                            { _symbol: "domain" },
                            { _symbol: "tasks" },
                            { 
                              _symbol: "map",
                              _stuff: [
                                {
                                  _symbol: "Lambda",
                                  task: { _symbol: "Argument", type: "Task" },
                                  _stuff: [
                                    {
                                      _symbol: "Li",
                                      _stuff: [
                                        {
                                          _symbol: "Div",
                                          class: "view",
                                          _stuff: [
                                            {
                                              _symbol: "Input",
                                              class: "toggle",
                                              type: "checkbox",
                                            },
                                            {
                                              _symbol: "Label",
                                              _stuff: {
                                                _symbol: "Chain",
                                                _stuff: [
                                                  { _symbol: "task" },
                                                  { _symbol: "title" }
                                                ]
                                              }
                                            },
                                            {
                                              _symbol: "Button",
                                              class: "destroy",
                                            }
                                          ]
                                        },
                                        {
                                          _symbol: "Input",
                                          class: "edit",
                                          value: {
                                            _symbol: "Chain",
                                            _stuff: [
                                              { _symbol: "task" },
                                              { _symbol: "title" }
                                            ]
                                          }
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      }
                    ]
                  },
                  {
                    _symbol: "Footer",
                    class: "footer",
                    _stuff: [
                      {
                        _symbol: "Span",
                        class: "todo-count",
                        _stuff: [
                          {
                            _symbol: "Strong",
                            _stuff: {
                              _symbol: "Chain",
                              _stuff: [
                                { _symbol: "domain" },
                                { _symbol: "tasks" },
                                { _symbol: "count" }
                              ]
                            }
                          },
                          {
                            _symbol: "Span",
                            _stuff: " "
                          },
                          {
                            _symbol: "Span",
                            _stuff: {
                              _symbol: "if",
                              cond: {
                                _symbol: "Chain",
                                _stuff: [
                                  { _symbol: "domain" },
                                  { _symbol: "tasks" },
                                  { _symbol: "count" },
                                  { 
                                    _symbol: "equals",
                                    _stuff: 1
                                  }
                                ]
                              },
                              then: "item",
                              else: "items"
                            }
                          },
                          {
                            _symbol: "Span",
                            _stuff: " left"
                          }
                        ]
                      },
                      {
                        _symbol: "Ul",
                        class: "filters",
                        _stuff: [
                          {
                            _symbol: "Li",
                            _stuff: [
                              {
                                _symbol: "A",
                                href: "#/",
                                class: "selected",
                                _stuff: "All"
                              }
                            ]
                          },
                          {
                            _symbol: "Span",
                          },
                          {
                            _symbol: "Li",
                            _stuff: [
                              {
                                _symbol: "A",
                                href: "#/active",
                                _stuff: "Active"
                              }
                            ]
                          },
                          {
                            _symbol: "Span",
                          },
                          {
                            _symbol: "Li",
                            _stuff: [
                              {
                                _symbol: "A",
                                href: "#/completed",
                                _stuff: "Completed"
                              }
                            ]
                          },
                        ]
                      },
                      {
                        _symbol: "Button",
                        class: "clear-completed",
                        _stuff: "Clear Completed"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            _symbol: "Footer",
            class: "info",
            _stuff: [
              {
                _symbol: "P",
                _stuff: "Double-click to edit a todo"
              },
              {
                _symbol: "P",
                _stuff: [
                  "Created by ",
                  {
                    _symbol: "A",
                    href: "http://github.com/emeitch/",
                    _stuff: "Hideyuki MORITA (emeitch)"
                  }
                ]
              },
              {
                _symbol: "P",
                _stuff: [
                  "Part of ",
                  {
                    _symbol: "A",
                    href: "http://todomvc.com",
                    _stuff: "TodoMVC"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  }
}


function flatten(array) {
  return Array.prototype.concat.apply([], array);
}


// Props base class for getOwnPropertyNames
class PropsBase {
  constructor(raws={}) {
    Object.assign(this, raws);
  }
  
  clone(params) {
    return Object.assign(new this.constructor(), this, params);
  }
  
  eval(env) {
    const keys = Object.getOwnPropertyNames(this);
    const raws = keys.reduce((p, k) => {
        const prop = this[k];
        return Object.assign(p, {[k]: prop.eval(env)});
      },
      {});
    return new this.constructor(raws);
  }
}
class Props extends PropsBase {
  get equals() {
    class PropEquals extends Box {
      apply(operand, env) {
        const left = JSON.stringify(env.upper(this).eval(env));
        const right = JSON.stringify(operand.stuff.one.eval(env));
        return Literal.create(left == right);
      }
    }
    
    return new PropEquals();
  }
  
  get map() {
    class PropMap extends Box {
      apply(operand, env) {
        const block = operand.stuff.one;
        const argkey = block.keys[0]; // todo key値の型と一致するか検証
        return env.upper(this).stuff.map(item => {
          const arg = item.eval(env);
          const props = block.props.clone({[argkey]: arg});
          const b = block.clone({props});
          return b.eval(env);
        });
      }
    };
    
    return new PropMap();
  }
  
  get count() {
    class PropCount extends Box {
      isReference() {
        return false;
      }
      
      apply(operand, env) {
        const count = env.upper(this).stuff.raws.length;
        return Literal.create(count);
      }
    }
    
    return new PropCount();
  }
}


class Stuff {
  constructor(raws=[]) {
    this.raws = raws;
  }
  
  clone(params) {
    return Object.assign(new this.constructor(), this, params);
  }
  
  get one() {
    return this.raws[0];
  }
  
  eval(env) {
    const raws = this.raws.map(c => c.eval(env));
    return new this.constructor(raws).flatten();
  }
  
  flatten() {
    const raws = this.raws.reduce((a, raw) => {
      if (raw instanceof Stuff) {
        return a.concat(raw.raws);
      } else {
        return a.concat([raw]);
      }
    }, []);
    return new this.constructor(raws);
  }
  
  map(f) {
    return new Stuff(this.raws.map(f));
  }
}


class Plugins {
  constructor() {
    this.rules = [];
    this.all = {};
  }
  
  get(symbol) {
    let plugin = this.all[symbol];
    if (plugin) {
      return plugin;
    }
    
    for (let rule of this.rules) {
      plugin = rule(symbol);
      if (plugin) {
        return plugin;
      }
    }

    return undefined;
  }

  rule(rule) {
    this.rules.push(rule);
  }
  
  set(symbol, box) {
    this.all[symbol] = box;
  }
}
const PLUGINS = new Plugins();

class Tree {
  constructor(root) {
    this.root = root;
    this.parentsMap = this.setupParents(root, [], new Map());
  }
  
  setupParents(box, path, map) {
    map.set(box, path);

    const pth = path.slice(); // dupulication
    pth.push(box);
    
    for (let key of box.keys) {
      const prop = box.props[key];
      this.setupParents(prop, pth, map);
    }
    
    for (let raw of box.stuff.raws) {
      this.setupParents(raw, pth, map);
    }
    
    return map;
  }
  
  parents(box) {
    const parents = this.parentsMap.get(box);
    return parents ? parents : [];
  }
  
  parent(box) {
    const parents = this.parents(box);
    return parents[parents.length-1];
  }
  
  get(key) {
    return this.root.get(key);
  }

  find(pred) {
    return this.root.find(pred);
  }
}

class Store {
  constructor(root) {
    this.srcs = [];
    this.dsts = [];
    
    this.append(root);
  }
  
  append(root) {
    const src = new Tree(root);
    this.srcs.push(src);
    
    const overlay = new Tree(src.root.overlay(new Environment(src)));
    const dst = new Tree(overlay.root.eval(new Environment(overlay)))
    this.dsts.push(dst);
  }

  get head() {
    return this.dsts[this.dsts.length-1];
  }
  
  parent(box) {
    const parent = this.head.parent(box);
    return parent ? parent : this;
  }

  replace(old, root) {
    this.append(root);
  }
  
  get(key) {
    return this.head.get(key);
  }
  
  find(pred) {
    return this.head.find(pred);
  }
}

class Environment {
  constructor(tree) {
    this.tree = tree;
    this.stacks = [];
  }
  
  stack(box, block) {
    this.stacks.push(box);
    const result = block();
    this.stacks.pop();
    return result;
  }
    
  context(current) {
    const parents = this.tree.parents(current);
    const context = parents.concat(this.stacks);
    context.reverse();
    return context;
  }
  
  ref(current, symbol) {
    for (let box of this.context(current)) {
      const prop = box.get(symbol);
      if (prop && prop != current) {
        return prop;
      }
    }
    
    const plugin = PLUGINS.get(symbol);
    if (plugin) {
      return plugin;
    }

    return undefined;
  }
  
  upper(current) {
    return this.context(current)[0];
  }  
}


class Box {
  static uuid() {
    var uuid = "", i, random;
    for (i = 0; i < 32; i++) {
      random = Math.random() * 16 | 0;
      
      if (i == 8 || i == 12 || i == 16 || i == 20) {
        uuid += "-"
      }
      uuid += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return uuid;
  }
  
  static parse(src, ...inheritedOptions) {
    {
      const type = typeof(src);
      if (Literal.types.includes(type)) {
        src = { _symbol: JSON.stringify(src) }
      }
    }
    
    const props = Object.getOwnPropertyNames(src)
      .filter(k => k[0] !== '_')
      .reduce((p, k) => Object.assign(p, {[k]: Box.parse(src[k])}), {});
      
    const on = src._on;
    if (on) {
      Object.getOwnPropertyNames(on).forEach(k => {
        const event = on[k];
        if (!event._symbol) {
          event._symbol = "Event";
        }
        props[k] = Box.parse(event);
      });
    }
    
    const relay = src._relay;
    if (relay) {
      Object.getOwnPropertyNames(relay).forEach(k => {
        const event = relay[k];
        if (!event._symbol) {
          event._symbol = "Event";
        }
        props[k] = Box.parse(event);
      });
    }
      
    const s = src._stuff;
    const stf = s ? (Array.isArray(s) ? s : [s]) : [];
    const stuff = stf.map(i => Box.parse(i));
    
    const plugin = PLUGINS.get(src._symbol);
    const cls = plugin && typeof(plugin) == "function" ? plugin : this;
    
    return new cls(
      src._symbol, 
      new Props(props),
      new Stuff(stuff),
      ...inheritedOptions);
  }
  
  static get evaluated() {
    return true;
  }
  
  static get props() {
    return new Props();
  }
  
  static get stuff() {
    return new Stuff();
  }
  
  static eval(env) {
    return this;
  }
  
  static apply(operand, env) {
    const props = operand.props.eval(env);
    const stuff = operand.stuff.eval(env);
    
    return operand.clone({
      props,
      stuff,
      evaluated: true
    });
  }
  
  static get(key) {
    return undefined;
  }
        
  constructor(symbol=undefined, props=new Props(), stuff=new Stuff(), evaluated=false) {
    this.id = this.constructor.uuid();
    this.symbol = symbol;
    this.props = props;
    this.stuff = stuff;
    this.evaluated = evaluated;
  }
    
  clone(params) {
    return Object.assign(new this.constructor(), this, params);
  }
    
  get keys() {
    return Object.getOwnPropertyNames(this.props)
  }
  
  isReference() {
    return this.keys.length == 0 && this.stuff.raws.length == 0;
  }
  
  overlay(env, inherit=undefined) {
    const proto = env.ref(this, this.symbol) || inherit;
    if (!proto) {
      return this;
    }
    
    const props = this.keys.reduce((ps, k) => {
      const prop = this.props[k];
      return Object.assign(ps, {[k]: prop.overlay(env, proto.props[k]) } );
    }, proto.props.clone());
    
    const stuff = this.stuff.raws.map((s, i) => {
      return s.overlay(env, proto.stuff.raws[i]);
    });
    
    if (proto.clone) {
      return proto.clone({
        props: new Props(props),
        stuff: new Stuff(stuff)
      });
    } else {
      return this.clone({
        props: new Props(props),
        stuff: new Stuff(stuff)
      });
    }
  }
  
  eval(env) {
    if (this.evaluated) {
      return this;
    }
    
    let proto = env.ref(this, this.symbol);
    if (!proto) {
      proto = Box;
    }
    
    const evaluated = proto.apply(this, env);
    return evaluated.eval(env);
  }
  
  apply(operand, env) {
    if (operand.isReference()) {
      return this; // reference
    }

    return this.constructor.apply(operand, env);
  }

  keyOf(child) {
    const key = this.keys.find(key => this.get(key) == child);
    const index = this.stuff.raws.findIndex(s => s == child);
    return key || index;
  }

  replace(old, child, store) {
    const key = this.keyOf(old);
    this.set(this.keyOf(old), child, store);
  }
  
  get(key) {
    const prop = this.props[key];
    if (prop) {
      return prop;
    }
        
    return undefined;
  }
  
  set(key, child, store) {
    if (typeof(key) === "string") {
      const props = this.props.clone({[key]: child});
      const clone = this.clone({props});
      const parent = store.parent(this);
      parent.replace(this, clone, store);
    } else if (typeof(key) === "number") {
      const stuff = this.stuff.clone();
      stuff.raws[key] = child;
      const clone = this.clone({stuff});
      const parent = store.parent(this);
      parent.replace(this, clone, store);
    }
  }
  
  find(pred) {
    // todo 探索遅いので最適化する
    for (let key of this.keys) {
      const box = this.get(key);
      if (pred(box)) {
        return box;
      }
      
      const result = box.find(pred);
      if (result) {
        return result;
      }      
    }
    
    for (let box of this.stuff.raws) {
      if (pred(box)) {
        return box;
      }
      
      const result = box.find(pred);
      if (result) {
        return result;
      }
    }
    
    return undefined;
  }
}
PLUGINS.set("Box", Box);


class Literal extends Box {
  static create(value) {
    return new this(JSON.stringify(value));
  }
  
  static get types() {
    return [
      "number",
      "string",
      "boolean"
    ];
  }
  
  apply(operand, env) {
    return this;
  }
  
  get value() {
    return JSON.parse(this.symbol);
  }
}
PLUGINS.rule(symbol => {
  try {
    const value = JSON.parse(symbol);
    const type = typeof(value);
    if (Literal.types.includes(type) || value == null) {
      return Literal;
    }
  } catch(e) {
    if (e instanceof SyntaxError) {
    } else {
      throw e;
    }
  }
  
  return undefined;
});

class Event extends Box {
}
PLUGINS.set("Event", Event);


class Self extends Box {
}
PLUGINS.set("self", Self);


class ArrayAppend extends Box {
}
PLUGINS.set("append", ArrayAppend)


class Chain extends Box {
  static apply(operand, env) {
    const raws = operand.stuff.raws;
    const chain = raws.slice(-(raws.length-1));
    const receiver = operand.stuff.one.eval(env);
    return chain.reduce((result, chained) => {
      const r = env.stack(result, () => chained.eval(env));
      if (!r) {
        throw "chain evaluated value is not set."
      }
      return r;
    },
    receiver);
  }
}
PLUGINS.set("Chain", Chain);


class If extends Box {
  static apply(operand, env) {
    const cond = operand.get("cond").eval(env).value;
    if (cond) {
      return operand.get("then").eval(env);
    } else {
      return operand.get("else").eval(env);
    }
  }
}
PLUGINS.set("if", If);

class Argument extends Box {
}
PLUGINS.set("Argument", Argument);

class Lambda extends Box {
  static apply(operand, env) {
    const item = operand.stuff.one;
    return env.stack(operand, () => item.eval(env));
  }
}
PLUGINS.set("Lambda", Lambda);


class Entity extends Box {
}
PLUGINS.set("Entity", Entity);


class DOM extends Box {
  static createHandlers(store) {
    return {
      keyup: (event) => {
        {
          const box = store.find(b => b.id == event.target.getAttribute("boxid"));
          box.set("value", Literal.create(event.target.value), store);
        }
        
        {
          const box = store.find(b => b.id == event.target.getAttribute("boxid"));
          const e = box.get(event.type);
          
          const env = new Environment(store.head);
          const adapt = e.eval(env);
          console.log(adapt.stuff.raws[0]);
        }
      }
    }
  }
  
  constructor(...args) {
    super(...args);
    // todo valueを参照されることがあるのでデフォルト値を設定している。後でうまく捌きたい
    this.props.value = Literal.create(null);
  }
  
  render(handlers) {
    const attrs = this.keys.reduce((r, k) => {
      const prop = this.props[k];
      if (prop instanceof Event) {
        return Object.assign(r, {["on"+k]: handlers[k]})
      } else {
        return Object.assign(r, {[k]: prop.value})  
      }
    }
    ,{});
    
    attrs["boxid"] = this.id;
    
    const children = flatten(this.stuff.raws.map(b => {
      if (b instanceof Literal) {
        return b.value || "";
      }
      
      if (b instanceof DOM) {
        return b.render(handlers);
      }
      
      return [];
    }));
    
    const vdom = maquette.h(
      this.tag,
      attrs,
      children
    );
    return [vdom];
  }
}
const HTML_TAGS = [
  "Body",
  "Section",
  "Footer",
  "Header",
  "P",
  "Ul",
  "Li",
  "Input",
  "Button",
  "Div",
  "Span",
  "H1",
  "Label",
  "Strong",
  "A",
];
for (let tag of HTML_TAGS) {
  const cls = class extends DOM {
    get tag() {
      return tag;
    }
  }
  PLUGINS.set(tag, cls);
}

PLUGINS.set("TodoMVC", Box.parse(jsonObject.TodoMVC));

const instance = {
  _symbol: "TodoMVC",
  domain: {
    tasks: {
      _stuff: [
        {
          _symbol: "Task",
          title: "buy a milk",
          completed: false,
        },
        {
          _symbol: "Task",
          title: "buy a coffee",
          completed: false,
        },
        {
          _symbol: "Task",
          title: "buy a tea",
          completed: true,
        }
      ]
    }
  }
};

const store = new Store(Box.parse(instance));
console.log(store.head.root);

const handlers = DOM.createHandlers(store);
function render() {
  const body = store.get("presentation").get("body");
  return body.render(handlers)[0];
}

var projector = maquette.createProjector();
window.document.addEventListener('DOMContentLoaded', function () {
   projector.replace(window.document.body, render);
});

</script>
</head>
<body>
</body>
</html>