<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>lay prototype</title>
<link rel="stylesheet" href="./base.css">
<link rel="stylesheet" href="./index.css">
<script src="maquette.min.js"></script>
<script>

function flatten(array) {
  return Array.prototype.concat.apply([], array);
}


// Props base class for getOwnPropertyNames
class PropsBase {
  constructor(raws={}) {
    Object.assign(this, raws);
  }
  
  clone(params) {
    const keys = Object.getOwnPropertyNames(this);
    const raws = keys.reduce((p, k) => {
        const prop = this[k];
        return Object.assign(p, {[k]: prop.clone()});
      },
      {});
    return Object.assign(new this.constructor(raws), params);
  }
  
  eval(ctx) {
    const keys = Object.getOwnPropertyNames(this);
    const raws = keys.reduce((p, k) => {
        const prop = this[k];
        return Object.assign(p, {[k]: prop.eval(ctx)});
      },
      {});
    return new this.constructor(raws);
  }
}
class Props extends PropsBase {
  equals(box) {
    class PropEquals extends Box {
      apply(operand, ctx) {
        const left = box.eval(ctx).value;
        const right = operand.stuff.one.eval(ctx).value;
        return Literal.create(left == right);
      }
    }
    
    return new PropEquals();
  }
  
  map(box) {
    class PropMap extends Box {
      apply(operand, ctx) {
        const block = operand.stuff.one;
        const argkey = block.keys[0]; // todo key値の型と一致するか検証
        return box.stuff.map(item => {
          const arg = item.eval(ctx);
          const props = block.props.clone({[argkey]: arg});
          const b = block.clone({props});
          return b.eval(ctx);
        });
      }
    };
    
    return new PropMap();
  }
  
  count(box) {
    class PropCount extends Box {
      apply(operand, ctx) {
        const count = box.stuff.raws.length;
        return Literal.create(count);
      }
    }
    
    return new PropCount();
  }
  
  set(box) {
    class PropSet extends Box {
      apply(operand, ctx) {
        return new Box(undefined, operand.props.clone(), operand.stuff.clone());
      }
    }
    
    return new PropSet();
  }
  
  append(box) {
    class PropAppend extends Box {
      apply(operand, ctx) {
        const stuff = new Stuff();
        stuff.raws[box.stuff.raws.length] = operand.stuff.one.eval(ctx); // push
        const updateBox = new Box(undefined, new Props(), stuff);
        return updateBox;
      }
    }
    
    return new PropAppend();
  }
}


class Stuff {
  constructor(raws=[]) {
    this.raws = raws;
  }
  
  clone() {
    const raws = this.raws.map(b => b.clone());
    return new this.constructor(raws);
  }
  
  get one() {
    return this.raws[0];
  }
  
  eval(ctx) {
    const raws = this.raws.map(c => c.eval(ctx));
    return new this.constructor(raws).flatten();
  }
  
  flatten() {
    let raws = [];
    let index = 0;
    for (var i = 0; i < this.raws.length; i++) {
      const raw = this.raws[i];
      if (raw instanceof Stuff) {
        for (var j = 0; j < raw.raws.length; j++) {
          const rr = raw.raws[j];
          if (Object.keys(raw.raws).indexOf(String(j)) != -1) {
            raws[index] = rr;
          }
          index++;
        }
      } else {
        if (Object.keys(this.raws).indexOf(String(i)) != -1) {
          raws[index] = raw;
        }
        index++;
      }
    }
    return new this.constructor(raws);
  }
  
  map(f) {
    return new Stuff(this.raws.map(f));
  }
}


class Environment {
  constructor() {
    this.rules = [];
    this.modules = {}
    this.stores = {};
    this.events = [];
  }
  
  get(symbol) {
    const imprt = this.modules[symbol];
    if (imprt) {
      return imprt;
    }
    
    const store = this.stores[symbol];
    if (store) {
      return store.head.root;
    }
    
    for (let rule of this.rules) {
      const box = rule(symbol);
      if (box) {
        return box;
      }
    }

    return undefined;
  }

  rule(rule) {
    this.rules.push(rule);
  }
  
  check(symbol) {
    if (this.modules[symbol] || this.stores[symbol]) {
      throw `"${symbol}" box is already exists!`
    }
  }
  
  import(symbol, box) {
    this.check(symbol);
    this.modules[symbol] = box;
  }
  
  store(symbol, box) {
    if (!box) {
      return this.stores[symbol];
    }
    
    this.check(symbol);
    this.stores[symbol] = new Store(box);
  }
  
  emit(ev) {
    if (ev instanceof Literal && ev.value == undefined) {
      // through event as undefined
      return;
    }
    
    this.events.push(ev);
  }
  
  run() {
    const mainstore = this.stores["main"];
    if (!mainstore) {
      throw `"main" store is not exists!`;
    }
    
    for (let key of Object.getOwnPropertyNames(this.modules)) {
      const module = this.modules[key];
      if (module.initialize) {
        module.initialize(mainstore);
      }
    }
    
    window.setInterval(() => {
      const events = this.events;
      this.events = [];
      for (const ev of events) {
        // todo evを参照可能な他のstoreにもemitさせる
        mainstore.emit(ev);
        
        for (let key of Object.getOwnPropertyNames(this.modules)) {
          const module = this.modules[key];
          if (module.update) {
            module.update(mainstore);
          }
        }
      }
    }, 1000 / 60);
  }
}
const ENV = new Environment();


class Tree {
  constructor(root) {
    this.root = root;
    this.parentsMap = this.setupParents(root, [], new Map());
  }
  
  setupParents(box, path, map) {
    if (map.get(box)) {
      throw "duplicated parents!"
    }
    
    map.set(box, path);

    const pth = path.slice(); // dupulication
    pth.push(box);
    
    if (box.proto) {
      this.setupParents(box.proto, pth, map);
    }
        
    for (let key of box.keys) {
      const prop = box.props[key];
      this.setupParents(prop, pth, map);
    }
    
    for (let raw of box.stuff.raws) {
      // 歯抜け配列の場合にrawにundefinedが渡ることがある
      if (raw) {
        this.setupParents(raw, pth, map);  
      }
    }
    
    return map;
  }
  
  parents(box) {
    const parents = this.parentsMap.get(box);
    return parents ? parents : [];
  }
  
  parent(box) {
    const parents = this.parents(box);
    return parents[parents.length-1];
  }
  
  get(key) {
    return this.root.get(key);
  }

  find(pred) {
    return this.root.find(pred);
  }
}


class Store {
  constructor(root) {
    this.events = [];
    this.updates = [];
    this.src = undefined;
    this.overlay = undefined;
    this.head = undefined;
    
    this.append(root);
  }
  
  append(root) {
    const update = new Tree(root);
    this.updates.push(update);
    
    if (!this.src) {
      this.src = update;
    } else {
      this.src = new Tree(update.root.overlay(new Context(update), this.src.root));
    }
    this.overlay = new Tree(this.src.root.overlay(new Context(this.src)));
    this.head = new Tree(this.overlay.root.eval(new Context(this.overlay)));
  }
  
  parent(box) {
    const parent = this.head.parent(box);
    return parent ? parent : this;
  }
  
  emit(ev) {
    this.events.push(ev);
    
    // todo 他のBoxが定義しているイベントもreceiveできるようにする
    const origEvent = this.overlay.find(b => ev.proto.id == b.id);
    const ctx = new Context(this.overlay);
    const st = new Box(undefined, ev.props);
    const updateEvent = ctx.stack(st, () => origEvent.eval(ctx));
    const updateBox = updateEvent.stuff.one;
    
    const headOrigEvent = this.head.find(b => ev.proto.id == b.id);
    const box = this.head.parent(headOrigEvent);
    
    for (let key of updateBox.keys) {
      box.set(key, updateBox.props[key], this);
    }
    
    for (let name of Object.keys(updateBox.stuff.raws)) {
      const index = parseInt(name);
      if (!Number.isNaN(index)) {
        box.set(index, updateBox.stuff.raws[index], this);
      }
    }
  }

  replace(old, update) {
    this.append(update);
  }
  
  get(key) {
    return this.head.get(key);
  }
  
  find(pred) {
    return this.head.find(pred);
  }
}


class Context {
  constructor(tree) {
    this.tree = tree;
    this.stacks = [];
  }
  
  stack(box, block) {
    if (box) {
      this.stacks.push(box);
    }
    
    const result = block();
    
    if (box) {
      this.stacks.pop();  
    }
    
    return result;
  }
    
  scope(current) {
    const parents = this.tree.parents(current);
    const context = parents.concat(this.stacks);
    context.reverse();
    return context;
  }
  
  ref(current, symbol) {
    if (symbol == "self") {
      const parents = this.tree.parents(current);
      // todo もう少しまともにselfのセマンティクスを定義したい
      const self = parents[parents.length - 3];
      return self;
    }
    
    for (let box of this.scope(current)) {
      const prop = box.get(symbol);
      if (prop && prop != current) {
        return prop;
      }
    }
    
    return ENV.get(symbol);
  }
  
  upper(current) {
    return this.scope(current)[0];
  }  
}


class Box {
  static uuid() {
    var uuid = "", i, random;
    for (i = 0; i < 32; i++) {
      random = Math.random() * 16 | 0;
      
      if (i == 8 || i == 12 || i == 16 || i == 20) {
        uuid += "-"
      }
      uuid += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return uuid;
  }
  
  static parse(src, ...inheritedOptions) {
    {
      const type = typeof(src);
      if (Literal.types.includes(type)) {
        return Literal.create(src);
      }
    }
    
    const props = Object.getOwnPropertyNames(src)
      .filter(k => k[0] !== '_')
      .reduce((p, k) => Object.assign(p, {[k]: Box.parse(src[k])}), {});
      
    const on = src._on;
    if (on) {
      Object.getOwnPropertyNames(on).forEach(k => {
        const event = on[k];
        if (!event._proto) {
          event._proto = "Event";
        }
        props[k] = Box.parse(event);
      });
    }
    
    const relay = src._relay;
    if (relay) {
      Object.getOwnPropertyNames(relay).forEach(k => {
        const event = relay[k];
        if (!event._proto) {
          event._proto = "Event";
        }
        props[k] = Box.parse(event);
      });
    }
      
    const s = src._stuff;
    const stf = s ? (Array.isArray(s) ? s : [s]) : [];
    const stuff = stf.map(i => Box.parse(i));
    
    const proto = src._proto ? Ref.create(src._proto) : undefined;
    
    return new this(
      proto,
      new Props(props),
      new Stuff(stuff),
      ...inheritedOptions);
  }
  
  constructor(proto=undefined, props=new Props(), stuff=new Stuff(), evaluated=false) {
    this.id = this.constructor.uuid();
    this.proto = proto;
    this.props = props;
    this.stuff = stuff;
    this.evaluated = evaluated;
  }
    
  clone(params) {
    const proto = this.proto ? this.proto.clone() : this.proto;
    const props = this.props.clone();
    const stuff = this.stuff.clone();
    return Object.assign(new this.constructor(),
      this,
      { proto, props, stuff },
      params);
  }
    
  get keys() {
    return Object.getOwnPropertyNames(this.props)
  }
  
  overlay(ctx, inherit=undefined) {
    const proto = this.proto && this.proto.eval(ctx) || inherit;
    if (!proto) {
      return this.clone();
    }
    
    const props = this.keys.reduce((ps, k) => {
      const prop = this.props[k];
      return Object.assign(ps, {[k]: prop.overlay(ctx, proto.props[k]) } );
    }, proto.props.clone());
    
    const stuff = Object.assign(
      proto.stuff.clone().raws, 
      this.stuff.raws.map((s, i) => {
        return s.overlay(ctx, proto.stuff.raws[i]);
      })
    );
    
    return this.clone({
      id: proto.id,
      proto: proto.proto ? proto.proto.clone() : proto.proto,
      props: new Props(props),
      stuff: new Stuff(stuff),
    });
  }
  
  eval(ctx) {
    if (this.evaluated) {
      return this;
    }
    
    const proto = this.proto && this.proto.eval(ctx) || new Box();
    
    if (proto.canApply(this, ctx)) {
      const applied = proto.apply(this, ctx);
      return applied.eval(ctx);
    } else {
      return this.clone({
        proto
      });
    }
  }
  
  canApply(operand, ctx) {
    return true;
  }
  
  apply(operand, ctx) {
    const props = operand.props.eval(ctx);
    const stuff = operand.stuff.eval(ctx);
    
    return operand.clone({
      proto: this,
      props,
      stuff,
      evaluated: true
    });
  }

  keyOf(child) {
    const key = this.keys.find(key => this.get(key) == child);
    const index = this.stuff.raws.findIndex(s => s == child);
    return key || index;
  }

  replace(child, update, store) {
    const key = this.keyOf(child);
    this.set(key, update, store);
  }
  
  get(key) {
    const prop = this.props[key];
    if (prop) {
      if (typeof(prop) == "function") {
        return prop(this);
      } else {
        return prop;  
      }
    }
        
    return undefined;
  }
  
  set(key, child, store) {
    if (typeof(key) === "string") {
      const props = new Props({[key]: child});
      const update = new Box(undefined, props, new Stuff());
      const parent = store.parent(this);
      parent.replace(this, update, store);
    } else if (typeof(key) === "number") {
      const raws = [];
      raws[key] = child;
      const stuff = new Stuff(raws);
      const update = new Box(undefined, new Props(), stuff);
      const parent = store.parent(this);
      parent.replace(this, update, store);
    }
  }
  
  find(pred) {
    // todo 探索遅いので最適化する
    for (let key of this.keys) {
      const box = this.get(key);
      if (pred(box)) {
        return box;
      }
      
      const result = box.find(pred);
      if (result) {
        return result;
      }      
    }
    
    for (let box of this.stuff.raws) {
      if (pred(box)) {
        return box;
      }
      
      const result = box.find(pred);
      if (result) {
        return result;
      }
    }
    
    return undefined;
  }
}
ENV.import("Box", new Box());


class Ref extends Box {
  static create(sym) {
    if (typeof(sym) == "string") {
      sym = [sym];
    }
    return new this(sym);
  }

  constructor(symbols) {
    super();
    this.symbols = symbols;
  }
  
  eval(ctx) {
    let receiver = ctx.ref(this, this.symbols[0]);
    
    const rest = this.symbols.slice(); // duplication
    rest.shift();
    for (const symbol of rest) {
      receiver = receiver.get(symbol);
      if (!receiver) {
        throw `"${symbol}" not found`
      }
    }
    return receiver ? receiver.clone({}) : receiver;
  }
}


class Literal extends Box {
  static create(value) {
    return new this(value);
  }
  
  static get types() {
    return [
      "number",
      "string",
      "boolean",
      "undefined"
    ];
  }
  
  constructor(value) {
    super();
    this.value = value;
  }
  
  apply(operand, ctx) {
    return this;
  }
}


class Event extends Box {
  canApply(operand, ctx) {
    for (let key of operand.keys) {
      const box = ctx.ref(operand, key);
      if (box) {
        continue;
      }

      const prop = operand.get(key);
      // todo 判定がダサい。。。
      if (prop.proto && (prop.proto.id == ENV.get("Argument").id || prop.proto instanceof Ref && prop.proto.symbols[0] == "Argument")) {
        return false;
      }
    }
    return true;
  }
}
ENV.import("Event", new Event());


class If extends Box {
  apply(operand, ctx) {
    const cond = operand.get("cond").eval(ctx).value;
    if (cond) {
      return operand.get("then").eval(ctx);
    } else {
      return operand.get("else").eval(ctx);
    }
  }
}
ENV.import("if", new If());


class Argument extends Box {
}
ENV.import("Argument", new Argument());


class Lambda extends Box {
  apply(operand, ctx) {
    const item = operand.stuff.one;
    return ctx.stack(operand, () => item.eval(ctx));
  }
}
ENV.import("Lambda", new Lambda());


class Entity extends Box {
}
ENV.import("Entity", new Entity());


class DOM extends Box {  
  constructor(tag) {
    super();
    this.tag = tag;
    
    // todo valueを参照されることがあるのでデフォルト値を設定している。後でうまく捌きたい
    this.props.value = Literal.create(null);
  }
  
  initialize(mainstore) {
    // one time only initializing
    if (this.tag != HTML_TAGS[0]) {
      return;
    }
    
    this.projector = maquette.createProjector();
    this.handlers = this.createHandlers(mainstore);
    
    console.log(mainstore.head.root);
    
    window.document.addEventListener('DOMContentLoaded', () => {
      this.projector.replace(window.document.body, () => {
        const body = mainstore.get("presentation").get("body");
        return this.render(body, this.handlers)[0];
      });
    });
  }
  
  update(mainstore) {
    // one time only updating
    if (this.tag != HTML_TAGS[0]) {
      return;
    }
    
    this.projector.renderNow();
  }
  
  createHandlers(store) {
    return {
      input: (ev) => {
        const box = store.find(b => b.id == ev.target.getAttribute("boxid"));
        const va = box.get("value");
        if (!va || va.value != ev.target.value) {
          box.set("value", Literal.create(ev.target.value), store);
          // console.log(`${box.id} value prop updated: "${ev.target.value}"`);
        }
      },
      keyup: (ev) => {
        const box = store.find(b => b.id == ev.target.getAttribute("boxid"));
        const src = box.get(ev.type);
        
        const ctx = new Context(store.head);
        const st = new Box(undefined, 
          new Props({
            event: new Box(undefined, 
              new Props({
                // todo keyCode以外の属性も転送する
                keyCode: Literal.create(ev.keyCode)
              })
            )
          })
        );
        
        const events = ctx.stack(st, () => src.stuff.one.eval(ctx));
        for (let event of events.stuff.raws) {
          ENV.emit(event);  
        }
      }
    }
  }
      
  render(box, handlers) {
    const attrs = box.keys.reduce((r, k) => {
      const prop = box.props[k];
      if (prop.proto.id == ENV.get("Event").id) {
        return Object.assign(r, {["on"+k]: handlers[k]})
      } else {
        return Object.assign(r, {[k]: prop.value})  
      }
    }
    ,{
      oninput: handlers["input"]
    });
    attrs["boxid"] = box.id;
    attrs["key"] = box.id;
    
    const children = flatten(box.stuff.raws.map(b => {
      if (b instanceof Literal) {
        return b.value || "";
      }
      
      return this.render(b, handlers);
    }));
    
    const tag = box.proto.tag;
    const vdom = maquette.h(
      tag,
      attrs,
      children
    );
    return [vdom];
  }
}
const HTML_TAGS = [
  "Body",
  "Section",
  "Footer",
  "Header",
  "P",
  "Ul",
  "Li",
  "Input",
  "Button",
  "Div",
  "Span",
  "H1",
  "Label",
  "Strong",
  "A",
];
for (let tag of HTML_TAGS) {
  ENV.import(tag, new DOM(tag));
}


const TodoMVC = {
  domain: {
    Task: {
      _proto: "Entity",
      title: "string",
      completed: "bool"
    },
    tasks: {
      _on: {
        create: {
          title: { _proto: "Argument", type: "string" },
          _stuff: {
            _proto: [
              "self",
              "append"
            ],
            _stuff: {
              _proto: "Task",
              title: { _proto: "title" },
              completed: false
            }
          }
        }
      },
      _stuff: [
      ]
    }
  },
  presentation: {
    body: {
      _proto: "Body",
      _stuff: [
        {
          _proto: "Section",
          class: "todoapp",
          _stuff: [
            {
              _proto: "Div",
              _stuff: [
                {
                  _proto: "Header",
                  class: "header",
                  _stuff: [
                    {
                      _proto: "H1",
                      _stuff: [
                        "todos"
                      ]
                    },
                    {
                      _proto: "Input",
                      class: "new-todo",
                      placeholder: "What needs to be done?",
                      _on: {
                        clear: {
                          _stuff: {
                            _proto: [
                              "self",
                              "set"
                            ],
                            value: "",
                          }
                        }
                      },
                      _relay: {
                        keyup: {
                          event: { _proto: "Argument", type: "Event" },
                          _stuff: {
                            _proto: "if",
                            cond: {
                              _proto: [
                                "event",
                                "keyCode",
                                "equals"
                              ],
                              _stuff: 13
                            },
                            then: {
                              _stuff: [
                                {
                                  _proto: [
                                    "domain",
                                    "tasks",
                                    "create"
                                  ],
                                  title: {
                                    _proto: "value"
                                  }
                                },
                                {
                                  _proto: "clear"
                                }
                              ]
                            },
                            else: {}
                          }
                        }
                      }
                    }
                  ]
                },
                {
                  _proto: "Section",
                  class: "main",
                  _stuff: [
                    {
                      _proto: "Input",
                      class: "toggle-all",
                      type: "checkbox"
                    },
                    {
                      _proto: "Ul",
                      class: "todo-list",
                      _stuff: { 
                        _proto: [
                          "domain",
                          "tasks",
                          "map"
                        ],
                        _stuff: [
                          {
                            _proto: "Lambda",
                            task: { _proto: "Argument", type: "Task" },
                            _stuff: [
                              {
                                _proto: "Li",
                                _stuff: [
                                  {
                                    _proto: "Div",
                                    class: "view",
                                    _stuff: [
                                      {
                                        _proto: "Input",
                                        class: "toggle",
                                        type: "checkbox",
                                      },
                                      {
                                        _proto: "Label",
                                        _stuff: {
                                          _proto: [
                                            "task",
                                            "title"
                                          ],
                                        }
                                      },
                                      {
                                        _proto: "Button",
                                        class: "destroy",
                                      }
                                    ]
                                  },
                                  {
                                    _proto: "Input",
                                    class: "edit",
                                    value: {
                                      _proto: [
                                        "task",
                                        "title"
                                      ],
                                    }
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    }
                  ]
                },
                {
                  _proto: "Footer",
                  class: "footer",
                  _stuff: [
                    {
                      _proto: "Span",
                      class: "todo-count",
                      _stuff: [
                        {
                          _proto: "Strong",
                          _stuff: {
                            _proto: [
                              "domain",
                              "tasks",
                              "count"
                            ]
                          }
                        },
                        {
                          _proto: "Span",
                          _stuff: " "
                        },
                        {
                          _proto: "Span",
                          _stuff: {
                            _proto: "if",
                            cond: {
                              _proto: [
                                "domain", 
                                "tasks", 
                                "count", 
                                "equals"
                              ],
                              _stuff: 1
                            },
                            then: "item",
                            else: "items"
                          }
                        },
                        {
                          _proto: "Span",
                          _stuff: " left"
                        }
                      ]
                    },
                    {
                      _proto: "Ul",
                      class: "filters",
                      _stuff: [
                        {
                          _proto: "Li",
                          _stuff: [
                            {
                              _proto: "A",
                              href: "#/",
                              class: "selected",
                              _stuff: "All"
                            }
                          ]
                        },
                        {
                          _proto: "Span",
                        },
                        {
                          _proto: "Li",
                          _stuff: [
                            {
                              _proto: "A",
                              href: "#/active",
                              _stuff: "Active"
                            }
                          ]
                        },
                        {
                          _proto: "Span",
                        },
                        {
                          _proto: "Li",
                          _stuff: [
                            {
                              _proto: "A",
                              href: "#/completed",
                              _stuff: "Completed"
                            }
                          ]
                        },
                      ]
                    },
                    {
                      _proto: "Button",
                      class: "clear-completed",
                      _stuff: "Clear Completed"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          _proto: "Footer",
          class: "info",
          _stuff: [
            {
              _proto: "P",
              _stuff: "Double-click to edit a todo"
            },
            {
              _proto: "P",
              _stuff: [
                "Created by ",
                {
                  _proto: "A",
                  href: "http://github.com/emeitch/",
                  _stuff: "Hideyuki MORITA (emeitch)"
                }
              ]
            },
            {
              _proto: "P",
              _stuff: [
                "Part of ",
                {
                  _proto: "A",
                  href: "http://todomvc.com",
                  _stuff: "TodoMVC"
                }
              ]
            }
          ]
        }
      ]
    }
  }
};
ENV.import("TodoMVC", Box.parse(TodoMVC));


const main = {
  _proto: "TodoMVC",
  domain: {
    tasks: {
      _stuff: [
        {
          _proto: "Task",
          title: "buy a milk",
          completed: false,
        },
        {
          _proto: "Task",
          title: "buy a coffee",
          completed: false,
        },
        {
          _proto: "Task",
          title: "buy a tea",
          completed: true,
        }
      ]
    }
  }
};
ENV.store("main", Box.parse(main));
ENV.run();


</script>
</head>
<body>
</body>
</html>