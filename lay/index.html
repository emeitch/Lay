<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>lay prototype</title>
<link rel="stylesheet" href="./base.css">
<link rel="stylesheet" href="./index.css">
<script src="maquette.min.js"></script>
<script>
var jsonObject = {
  TodoMVC: {
    domain: {
      Task: {
        _proto: "Entity",
        title: "string",
        completed: "bool"
      },
      tasks: {
        _stuff: [
          {
            _proto: "Task",
            title: "buy a milk",
            completed: false,
          },
          {
            _proto: "Task",
            title: "buy a coffee",
            completed: false,
          },
          {
            _proto: "Task",
            title: "buy a tea",
            completed: true,
          }
        ]
      }
    },
    presentation: {
      _proto: "DOM::Document",
      body: {
        _proto: "Body",
        _stuff: [
          {
            _proto: "Section",
            class: "todoapp",
            _stuff: [
              {
                _proto: "Div",
                _stuff: [
                  {
                    _proto: "Header",
                    class: "header",
                    _stuff: [
                      {
                        _proto: "H1",
                        _stuff: [
                          "todos"
                        ]
                      },
                      {
                        _proto: "Input",
                        class: "new-todo",
                        placeholder: "What needs to be done?"
                      }
                    ]
                  },
                  {
                    _proto: "Section",
                    class: "main",
                    _stuff: [
                      {
                        _proto: "Input",
                        class: "toggle-all",
                        type: "checkbox"
                      },
                      {
                        _proto: "Ul",
                        class: "todo-list",
                        _stuff: [
                          {
                            _proto: "domain.tasks.map",
                            _stuff: [
                              {
                                _proto: "Lambda",
                                task: "Task",
                                _stuff: [
                                  {
                                    _proto: "Li",
                                    _stuff: [
                                      {
                                        _proto: "Div",
                                        class: "view",
                                        _stuff: [
                                          {
                                            _proto: "Input",
                                            class: "toggle",
                                            type: "checkbox",
                                          },
                                          {
                                            _proto: "Label",
                                            _stuff: [
                                              {
                                                _proto: "Ref",
                                                _path: "task.title"
                                              }
                                            ]
                                          },
                                          {
                                            _proto: "Button",
                                            class: "destroy",
                                          }
                                        ]
                                      },
                                      {
                                        _proto: "Input",
                                        class: "edit",
                                        value: {
                                          _proto: "Ref",
                                          _path: "task.title"
                                        }
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    _proto: "Footer",
                    class: "footer",
                    _stuff: [
                      {
                        _proto: "Span",
                        class: "todo-count",
                        _stuff: [
                          {
                            _proto: "Strong",
                            _stuff: "1"
                          },
                          {
                            _proto: "Span",
                          },
                          {
                            _proto: "Span",
                            _stuff: "item"
                          },
                          {
                            _proto: "Span",
                            _stuff: " left"
                          }
                        ]
                      },
                      {
                        _proto: "Ul",
                        class: "filters",
                        _stuff: [
                          {
                            _proto: "Li",
                            _stuff: [
                              {
                                _proto: "A",
                                href: "#/",
                                class: "selected",
                                _stuff: "All"
                              }
                            ]
                          },
                          {
                            _proto: "Span",
                          },
                          {
                            _proto: "Li",
                            _stuff: [
                              {
                                _proto: "A",
                                href: "#/active",
                                _stuff: "Active"
                              }
                            ]
                          },
                          {
                            _proto: "Span",
                          },
                          {
                            _proto: "Li",
                            _stuff: [
                              {
                                _proto: "A",
                                href: "#/completed",
                                _stuff: "Completed"
                              }
                            ]
                          },
                        ]
                      },
                      {
                        _proto: "Button",
                        class: "clear-completed",
                        _stuff: "Clear Completed"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            _proto: "Footer",
            class: "info",
            _stuff: [
              {
                _proto: "P",
                _stuff: "Double-click to edit a todo"
              },
              {
                _proto: "P",
                _stuff: [
                  "Created by ",
                  {
                    _proto: "A",
                    href: "http://github.com/emeitch/",
                    _stuff: "Hideyuki MORITA (emeitch)"
                  }
                ]
              },
              {
                _proto: "P",
                _stuff: [
                  "Part of ",
                  {
                    _proto: "A",
                    href: "http://todomvc.com",
                    _stuff: "TodoMVC"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  }
}

function flatten(array) {
  return Array.prototype.concat.apply([], array);
}

const PRIMITIVE_TYPES = [
  "number",
  "string",
  "boolean"
];

const HTML_TAGS = [
  "Body",
  "Section",
  "Footer",
  "Header",
  "P",
  "Ul",
  "Li",
  "Input",
  "Button",
  "Div",
  "Span",
  "H1",
  "Label",
  "Strong",
  "A",
]

function box(src={}) {
  const type = typeof(src);
  if (PRIMITIVE_TYPES.includes(type)) {
    return new Primitive(src);
  }
  
  if (src._proto === "Ref") {
    return new Ref(src);
  }
  
  if (src._proto === "Lambda") {
    return new Lambda(src);
  }
  
  if (HTML_TAGS.includes(src._proto)) {
    return new DOM(src);
  }
  
  if (src._proto === "Entity") {
    return new Entity(src);
  }
  
  return new Box(src);
}

class Stuff {
  constructor(items=[]) {
    this._items = items;
  }
  
  get _one() {
    return this._items[0];
  }
    
  _clone() {
    let clone = new this.constructor([]);
    clone._items = this._items.map(c => c._clone());
    return clone;
  }
  
  _eval(context) {
    let result = this._clone();
    result._items = this._items.map(c => c._eval(context))
    return result._flatten();
  }
  
  _flatten() {
    const flatten = this._clone();
    flatten._items = this._items.reduce((a, item) => {
      if (item instanceof Stuff) {
        return a.concat(item._items);
      } else {
        return a.concat([item]);
      }
    }, []);
    return flatten;
  }
  
  _map(f) {
    const result = new Stuff(this._items.map(f));
    return result;
  }
}

class Box {
  constructor(src) {
    this._protoPath = src._proto ? src._proto : "Box"
    
    Object.getOwnPropertyNames(src)
    .filter(n => n[0] != "_")
    .forEach(c => {
      this[c] = box(src[c]);
    });
    
    let items = [];
    if (Array.isArray(src._stuff)) {
      items = src._stuff;
    } else if (src._stuff) {
      items = [src._stuff];
    }
    this._stuff = new Stuff(items.map(b => box(b)));
  }
    
  _clone() {
    let clone = new this.constructor({});
    clone._protoPath = this._protoPath;
    this._keys.forEach(n => {
      clone[n] = this[n]._clone();
    });
    clone._stuff = this._stuff._clone();
    return clone;
  }
  
  _proto(context) {
    return this._ref(this._protoPath, context);
  }
  
  get _keys() {
    return Object.getOwnPropertyNames(this)
      .filter(n => n[0] != "_");
  }
  
  get _props() {
    return this._keys
      .reduce((r, n) => {
        r[n] = this[n];
        return r;
      }, {});
  }
  
  get _item() {
    return this._stuff._one;
  }
  
  _eval(context=[]) {
    const proto = this._proto(context);
    return proto._apply(this, context);
  }
  
  _apply(args, context) {
    let result = args._clone();
    
    context = context.slice() // duplication
    context.push(result);
    
    result._keys.forEach(n => {
      result[n] = result[n]._eval(context);
    });
    result._stuff = result._stuff._eval(context);
    return result;
  }
  
  _ref(path, context) {
    const syms = path.split(".");
    
    if (this[syms[0]]) {
      return syms.reduce((p, s) => p[s], this);      
    }
    
    context = context.slice(); // duplication
    const parent = context.pop(); // with side-effects for context
    if (parent) {
      return parent._ref(path, context);
    }
    
    return box(); // todo ダミーBoxを返している状況なので変更する
  }
    
  get map() {
    class Map extends Box {
      _apply(argbox, context) {
        const block = argbox._item;
        const barg = argbox._item._keys[0]; // todo key値の型と一致するか確認
        return this._target._stuff._map(item => {
          // todo _stuffにMapボックスが存在すると無限ループになるのをうまく解決 / そもそも_stuffがMapボックスになる状況のセマンティクスとは何か?
          const n = block._clone();
          n[barg] = item;
          return n._eval(context);
        });
      }
    }
    let m = new Map({});
    m._target = this;
    return m;
  }
}

class Primitive extends Box {
  constructor(src) {
    super({_proto: "Primitive"});
    this._val = src;
  }
  
  _clone() {
    let copy = super._clone();
    copy._val = this._val;
    return copy;
  }
  
  _value() {
    return this._val;
  }
}

class Entity extends Box {
}

class RefProto extends Box {
  _apply(argbox, context) {
    const b = argbox._ref(argbox._path, context);
    return b._eval(context);
  }
}
const REF_PROTO = new RefProto({});

class Ref extends Box {
  constructor(src) {
    super(src);
    this._path = src._path;
  }
  
  _proto(context) {
    return REF_PROTO;
  }
  
  _clone() {
    let copy = super._clone();
    copy._path = this._path;
    return copy;
  }
  
  _value() {
    return this._ref(this._path)._value();
  }
}

class LambdaProto extends Box {
  _apply(argbox, context) {
    // argbox内のブロック引数を参照できるようにするために
    // argboxをコンテキストに追加し
    // _itemのみを_evalした結果を返し簡約する
    
    context = context.slice() // duplication
    context.push(argbox);
    return argbox._item._eval(context);
  }
}
const LAMBDA_PROTO = new LambdaProto({});
class Lambda extends Box {
  _proto(context) {
    return LAMBDA_PROTO;
  }
}

class DOM extends Box {
  constructor(src) {
    super(src);
    this._tag = src._proto;
  }

  _clone() {
    let copy = super._clone();
    copy._tag = this._tag;
    return copy;
  }

  _render() {
    const attrs = this._keys.reduce((r, n) => Object.assign(r, {[n]: this[n]._val}), {});
    const children = flatten(this._stuff._items.map(b => {
      if (b._value) {
        return b._value();
      }
      
      if (b._render) {
        return b._render();
      }
      
      return [];
    }));
    return [maquette.h(
      this._tag,
      attrs,
      children
    )];
  }
}

function vdom(src) { 
  const app = src._eval();
  console.log(app);
  return app.presentation.body._render()[0];
}

const tree = box(jsonObject);

// Initializes the projector 
var projector = maquette.createProjector();
window.document.addEventListener('DOMContentLoaded', function () {
   projector.replace(window.document.body, () => vdom(tree.TodoMVC));
});

</script>
</head>
<body>
</body>
</html>