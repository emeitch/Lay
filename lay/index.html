<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>lay prototype</title>
<link rel="stylesheet" href="./base.css">
<link rel="stylesheet" href="./index.css">
<script src="maquette.min.js"></script>
<script>


function flatten(array) {
  return Array.prototype.concat.apply([], array);
}

const TodoMVC = {
  domain: {
    Task: {
      _proto: "Entity",
      title: "string",
      completed: "bool"
    },
    tasks: {
      create: {
        _proto: "EventListener",
        title: { _proto: "Argument", type: "string" },
        _stuff: {
          _proto: [
            "self",
            "append"
          ],
          _stuff: {
            _proto: "Task",
            id: { _proto: "UUID" },
            title: { _proto: "title" },
            completed: false
          }
        }
      },
      all: {
        // todo 本当はただのparent参照にしたいがうまくいかないので無駄にfilterかける
        _proto: [
          "parent",
          "filter"
        ],
        _stuff: {
          _proto: "Lambda",
          task: { _proto: "argument", type: "Task" },
          _stuff: true
        }
      },
      active: {
        _proto: [
          "parent",
          "filter"
        ],
        _stuff: {
          _proto: "Lambda",
          task: { _proto: "Argument", type: "Task" },
          _stuff: {
            _proto: "not",
            _stuff: {
              _proto: [
                "task",
                "completed",
              ]
            }
          }
        }
      },
      completed: {
        _proto: [
          "parent",
          "filter"
        ],
        _stuff: {
          _proto: "Lambda",
          task: { _proto: "Argument", type: "Task" },
          _stuff: {
            _proto: [
              "task",
              "completed",
            ]
          }
        }
      },
      _stuff: [
      ]
    }
  },
  presentation: {
    location: {
      hash: "",
    },
    // taskList: {
    //   _proto: "if",
    //   cond: {
    //     _proto: [
    //       "location",
    //       "hash",
    //       "equals"
    //     ],
    //     _stuff: "#/active"
    //   },
    //   then: {
    //     _proto: [
    //       "domain",
    //       "tasks",
    //       "active",
    //       "filter"
    //     ],
    //     _stuff: {
    //       _proto: "Lambda",
    //       task: { _proto: "argument", type: "Task" },
    //       _stuff: true
    //     }
    //   },
    //   else: {
    //     _proto: "if",
    //     cond: {
    //       _proto: [
    //         "location",
    //         "hash",
    //         "equals"
    //       ],
    //       _stuff: "#/completed"
    //     },
    //     then: {
    //       _proto: [
    //         "domain",
    //         "tasks",
    //         "completed",
    //         "filter"
    //       ],
    //       _stuff: {
    //         _proto: "Lambda",
    //         task: { _proto: "argument", type: "Task" },
    //         _stuff: true
    //       }
    //     },
    //     else: {
    //       _proto: [
    //         "domain",
    //         "tasks",
    //         "all",
    //         "filter"
    //       ],
    //       _stuff: {
    //         _proto: "Lambda",
    //         task: { _proto: "argument", type: "Task" },
    //         _stuff: true
    //       }
    //     }
    //   }
    // },
    body: {
      _proto: "Body",
      _stuff: [
        {
          _proto: "Section",
          class: "todoapp",
          _stuff: [
            {
              _proto: "Div",
              _stuff: [
                {
                  _proto: "Header",
                  class: "header",
                  _stuff: [
                    {
                      _proto: "H1",
                      _stuff: [
                        "todos"
                      ]
                    },
                    {
                      _proto: "Input",
                      class: "new-todo",
                      placeholder: "What needs to be done?",
                      autofocus: true,
                      clear: {
                        _proto: "EventListener",
                        _stuff: {
                          _proto: [
                            "self",
                            "set"
                          ],
                          value: "",
                        }
                      },
                      keyup: {
                        _proto: "EventListener",
                        keyCode: { _proto: "Argument", type: "Literal" },
                        _stuff: {
                          _proto: "if",
                          cond: {
                            _proto: [
                              "keyCode",
                              "equals"
                            ],
                            _stuff: 13
                          },
                          then: {
                            _proto: "Stuff",
                            _stuff: [
                              {
                                _proto: [
                                  "domain",
                                  "tasks",
                                  "create"
                                ],
                                title: {
                                  _proto: "value"
                                }
                              },
                              {
                                _proto: "clear"
                              }
                            ]
                          },
                          else: undefined
                        }
                      }
                    }
                  ]
                },
                {
                  _proto: "Section",
                  class: "main",
                  _stuff: [
                    {
                      _proto: "Input",
                      class: "toggle-all",
                      type: "checkbox"
                    },
                    {
                      _proto: "Ul",
                      class: "todo-list",
                      _stuff: { 
                        _proto: [
                          "domain",
                          "tasks",
                          "map"
                        ],
                        _stuff: [
                          {
                            _proto: "Lambda",
                            task: { _proto: "Argument", type: "Task" },
                            _stuff: [
                              {
                                _proto: "Li",
                                key: {
                                  _proto: [
                                    "task",
                                    "id"
                                  ]
                                },
                                _stuff: [
                                  {
                                    _proto: "Div",
                                    class: "view",
                                    _stuff: [
                                      {
                                        _proto: "Input",
                                        class: "toggle",
                                        type: "checkbox",
                                      },
                                      {
                                        _proto: "Label",
                                        _stuff: {
                                          _proto: [
                                            "task",
                                            "title"
                                          ],
                                        }
                                      },
                                      {
                                        _proto: "Button",
                                        class: "destroy",
                                      }
                                    ]
                                  },
                                  {
                                    _proto: "Input",
                                    class: "edit",
                                    value: {
                                      _proto: [
                                        "task",
                                        "title"
                                      ],
                                    }
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    }
                  ]
                },
                {
                  _proto: "Footer",
                  class: "footer",
                  _stuff: [
                    {
                      _proto: "Span",
                      class: "todo-count",
                      _stuff: [
                        {
                          _proto: "Strong",
                          _stuff: {
                            _proto: [
                              "domain",
                              "tasks",
                              "count"
                            ]
                          }
                        },
                        {
                          _proto: "Span",
                          _stuff: " "
                        },
                        {
                          _proto: "Span",
                          _stuff: {
                            _proto: "if",
                            cond: {
                              _proto: [
                                "domain", 
                                "tasks", 
                                "count", 
                                "equals"
                              ],
                              _stuff: 1
                            },
                            then: "item",
                            else: "items"
                          }
                        },
                        {
                          _proto: "Span",
                          _stuff: " left"
                        }
                      ]
                    },
                    {
                      _proto: "Ul",
                      class: "filters",
                      _stuff: [
                        {
                          _proto: "Li",
                          _stuff: [
                            {
                              _proto: "A",
                              href: "#/",
                              class: "selected",
                              _stuff: "All"
                            }
                          ]
                        },
                        {
                          _proto: "Span",
                        },
                        {
                          _proto: "Li",
                          _stuff: [
                            {
                              _proto: "A",
                              href: "#/active",
                              _stuff: "Active"
                            }
                          ]
                        },
                        {
                          _proto: "Span",
                        },
                        {
                          _proto: "Li",
                          _stuff: [
                            {
                              _proto: "A",
                              href: "#/completed",
                              _stuff: "Completed"
                            }
                          ]
                        },
                      ]
                    },
                    {
                      _proto: "Button",
                      class: "clear-completed",
                      _stuff: "Clear Completed"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          _proto: "Footer",
          class: "info",
          _stuff: [
            {
              _proto: "P",
              _stuff: "Double-click to edit a todo"
            },
            {
              _proto: "P",
              _stuff: [
                "Created by ",
                {
                  _proto: "A",
                  href: "http://github.com/emeitch/",
                  _stuff: "Hideyuki MORITA (emeitch)"
                }
              ]
            },
            {
              _proto: "P",
              _stuff: [
                "Part of ",
                {
                  _proto: "A",
                  href: "http://todomvc.com",
                  _stuff: "TodoMVC"
                }
              ]
            }
          ]
        }
      ]
    }
  }
};
// console.log(TodoMVC);
  
Object.prototype.equals = function(other) {
  return JSON.stringify(this) === JSON.stringify(other);
};
Object.prototype.notEquals = function(other) {
  return !this.equals(other);
}
class LayObject {
  constructor(obj={}) {
    Object.assign(this, obj);
  }
}

class Error extends LayObject {
}

class TypeError extends Error {
}

class RequiredPropertyError extends Error {
}

class Value extends LayObject {
}

class Entity extends LayObject {
}

class Path extends LayObject {
  static generateUUID() {
    // UUID ver 4 / RFC 4122
    var uuid = "", i, random;
    for (i = 0; i < 32; i++) {
      random = Math.random() * 16 | 0;
      
      if (i == 8 || i == 12 || i == 16 || i == 20) {
        uuid += "-"
      }
      uuid += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return uuid;
  }

  static uuid() {
    return "urn:uuid:" + this.generateUUID();
  }
  
  static isUUID(key) {
    return key.match(/^urn:uuid:/);
  }
  
  static isName(key) {
    return !this.isUUID(key);
  }

  constructor(...keys) {
    super();
    this.keys = keys;
  }
  
  get top() {
    return this.keys[0];
  }
  
  get last() {
    return this.keys[this.keys.length-1];
  }
  
  get rest() {
    return this.keys.slice(1);
  }
  
  parent() {
    if (this.keys.length == 1) {
      return undefined;
    }
    
    const keys = this.keys.concat();
    keys.pop();
    return new this.constructor(...keys);
  }
  
  child(key) {
    const keys = this.keys.concat([key]);
    return new this.constructor(...keys);
  }
}

class Store {
  constructor() {
    // premitives
    this.append(Object.assign(new Boolean(false), {
      _name: Boolean.name, 
      _abstract: true
    }));
    this.append(Object.assign(new Number(0), {
      _name: Number.name,
      _abstract: true
    }));
    this.append(Object.assign(new String(""), {
      _name: String.name,
      _abstract: true
    }));
    this.append(Object.assign(new Array(), {
      _name: Array.name,
      _abstract: true
    }));
    this.append(new Value({
      _name: Value.name,
      _abstract: true
    }));
    this.append(new Entity({
      _name: Entity.name,
      _abstract: true
    }));
    
    this.append(new Error({_name: Error.name}));
    this.append(new TypeError({_name: TypeError.name}));
    this.append(new RequiredPropertyError({_name: RequiredPropertyError.name}));
  }
  
  protoOf(object) {
    const protoPath = object._proto;
    if (protoPath) {
      return this.getByPath(protoPath);
    }

    return undefined;
  }
  
  entities(object) {
    const entities = {};
    
    let proto = this.protoOf(object);
    while (proto) {
      const obj = proto.obj;
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          const o = obj[key];
          if (o instanceof Entity && !entities[key]) {
            entities[key] = o;
          }
        }
      }
      
      proto = proto.proto;
    }
    
    return entities;
  }
  
  setObj(key, object) {
    if (object == null) {
      delete this[key];
      return undefined;
    }
    
    const box = this.get(key);
    
    const proto = this.protoOf(object);
    const error = proto ? proto.validate(object) : undefined;
    if (error) {
      this[key] = error;
      return this.get(key);
    }
    
    const name = object._name;
    if (name) {
      this.setObj(name, new Path(key));
      
      if (box && box.name && box.name != name) {
        this.setObj(box.name, null);
      }
    }
    
    for (const k in object) {
      if (object.hasOwnProperty(k)) {
        const o = object[k];
        
        // symbol referencing termination
        if (o instanceof Path && Path.isName(o.top) && o.rest.length == 0) {
          if (o.top == object._name) {
            // for recurcive definition
            object[k] = new Path(key);
          } else {
            object[k] = this.getByPath(o).path;
          }
        }
        
        // remove null property
        if (o === null) {
          delete object[k];
        }
      }
    }
     
    const entities = this.entities(object);
    for (const k in entities) {
      if (entities.hasOwnProperty(k)) {
        // remove old child parent
        if (box) {
          const old = box.get(k);
          if (old) {
            const o = Object.assign({}, old.obj, {_parent: null});
            old.update(o);
          }
        }
        
        const entity = entities[k];
        const override = object[k];
        const obj = override ? Object.assign({}, entity, override) : entity;
        const childId = obj._id || Path.uuid();
        
        delete obj._id;
        obj._parent = new Path(key);
        
        this.setObj(childId, obj);
        object[k] = new Path(childId);
      }
    }
    
    this[key] = object;
    return this.get(key);
  }
  
  append(object) {
    const key = Path.uuid();
    return this.setObj(key, object);
  }
  
  getObj(key) {
    return this[key];
  }

  getByPath(path) {
    const box = new Box(this, path);
    if (!box.obj) {
      return undefined;
    } else if (box.obj instanceof Path) {
      let b = this;
      for (const k of box.obj.keys) {
        b = b.get(k);
      }
      return b;
    }
    
    return box;
  }

  get(key) {
    return this.getByPath(new Path(key));
  }
}

class Box {
  constructor(store, path) {
    this.store = store;
    this.path = path;
  }
  
  get proto() {
    return this.store.protoOf(this.obj);
  }
  
  get parent() {
    const parentPath = this.obj._parent;
    if (parentPath) {
      return store.getByPath(parentPath);
    }
    return undefined;
  }
  
  get isAbstract() {
    return this.obj._abstract;
  }
  
  get name() {
    return this.obj._name;
  }
  
  get obj() {
    let v = this.store.getObj(this.path.top);
    for (const key of this.path.rest) {
      v = v[key];
    }
    return v;
  }
  
  equals(other) {
    return this.path.equals(other.path);
  }
  
  validate(object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        const v = object[key];
        const prop = this.get(key);
        const pv = (prop && prop.obj) || prop;
        if (pv 
          && pv.notEquals(v.__proto__) 
          && pv.__proto__.notEquals(v.__proto__)) {
          return new Value({
            _proto: new Path(TypeError.name),
          });
        }
      }
    }
    
    for (var key in this.obj) {
      if (this.obj.hasOwnProperty(key)) {
        if (this.get(key).isAbstract && object[key] == undefined) {
          return new Value({
            _proto: new Path(RequiredPropertyError.name),
          });
        }
      }
    }
    
    return null;
  }
    
  get(key) {
    const v = this.obj[key];
    if (v instanceof Path) {
      // reference entity
      return this.store.getByPath(v);
    } else if (v instanceof Object) {
      // nested value
      return this.store.getByPath(this.path.child(key));
    } else if (v == undefined && this.proto != undefined) {
      // prototype chain
      return this.proto.get(key);
    } else {
      return v;
    }
  }

  update(obj) {
    const object = Object.assign({}, this.obj, obj);
    const parentPath = this.path.parent();
    if (parentPath) {
      this.store.getByPath(parentPath).update({[this.path.last]: object});  
    } else {
      this.store.setObj(this.path.top, object);
    }
  }
  
  set(key, value) {
    const obj = {[key]: value};
    this.update(obj);
  }
}


// test suite
const store = new Store();

const p1 = store.append({
  _name: "proto1",
  foo: 1,
  bar: 2,
  fiz: 9
});
const b2id = Path.uuid();
const b1 = store.append({
  _proto: p1.path,
  foo: 3, 
  bar: 4,
  baz: new Path(b2id)
});
const b2 = store.setObj(b2id, {
  _proto: p1.path,
  foo: 5,
  bar: 6,
  baz: b1.path
});
const b3 = store.append({
  _proto: p1.path,
  foo: 5,
  bar: 6,
  baz: b1.path
});

// box generation
console.assert(b1.path instanceof Path);
console.assert(b2.path instanceof Path);

// box property access
console.assert(b1.get("foo") == 3);
console.assert(b1.get("bar") == 4);
console.assert(b2.get("foo") == 5);
console.assert(b2.get("bar") == 6);

// circular referencing
console.assert(b2.get("baz").equals(b1));
console.assert(b2.get("baz").get("baz").equals(b2));
console.assert(b2.get("baz").get("baz").get("baz").equals(b1));

// prototype definition
console.assert(b2.get("_proto").equals(p1));
console.assert(b2.proto.equals(p1));
console.assert(b2.proto.name == "proto1");

// get method returns raw id value
console.assert(store.getObj("proto1").equals(p1.path));
// box method resolves id reference
console.assert(store.get("proto1").equals(p1));

// prototype chain
console.assert(b2.get("fiz") == 9);

// equivalency
console.assert(b2.obj.equals(b3.obj));
console.assert(b2.obj.notEquals(b1.obj));


// entity schema for composition
const k2 = "proto2";
const p2 = store.append({
  _name: k2,
  foo: new Entity({
    bar: 3,
    baz: 4,
  }),
});
const b4 = store.append({
  _proto: new Path(k2),
  foo: {
    baz: 5,
  },
  fiz: 9,
});

// instantiation with proto entity generates a child box
console.assert(p2.get("foo").path.keys.length == 2);
console.assert(b4.get("foo").path.keys.length == 1);
console.assert(p2.get("foo").path.top.equals(p2.path.top));
console.assert(p2.get("foo").path.keys[1] == "foo");
console.assert(b4.get("foo").path.top.notEquals(b4.path.top));
// prototype chain by entity
console.assert(b4.get("foo").get("bar") == 3);
// parent entity access
console.assert(b4.get("foo").parent.equals(b4));
// override child entity property
console.assert(b4.get("foo").get("baz") == 5);

// update property
console.assert(b4.get("fiz") == 9);
b4.set("fiz", 8);
console.assert(b4.get("fiz") == 8);

// update child property
b4.get("foo").set("baz", 6);
console.assert(b4.get("foo").get("baz") == 6);

// update by object
b4.update({
  fiz: 9
});
console.assert(b4.get("fiz") == 9);

// update child by object
b4.get("foo").update({
  baz: 7
});
console.assert(b4.get("foo").get("baz") == 7);

// update parent and child by object
const oldFoo = b4.get("foo");
b4.update({
  fiz: 7,
  foo: {
    baz: 8
  }
});
console.assert(b4.get("fiz") == 7);
console.assert(b4.get("foo").get("baz") == 8);
console.assert(b4.get("foo").path.notEquals(oldFoo.path)); // updated
console.assert(oldFoo.obj._parent === undefined);
console.assert(oldFoo.parent === undefined);

// update parent and child by object with child identifier
const fooPath = b4.get("foo").path;
b4.update({
  fiz: 6, 
  foo: {
    _id: fooPath.top,
    baz: 9
  }
});
console.assert(b4.get("fiz") == 6);
console.assert(b4.get("foo").get("baz") == 9);
console.assert(b4.get("foo").path.equals(fooPath)); // not updated

// update proto's key name
console.assert(store.get("proto2"));
console.assert(!store.get("proto2dash"));
const k2dash = new Path("proto2dash");
p2.set("_name", k2dash.top);
console.assert(!store.get("proto2"));
console.assert(b4.proto.name == "proto2dash");
console.assert(store.get("proto2dash").equals(p2));


// nested value box
const b5 = store.append({
  hoge: 3,
  fuga: 4
});
const b6 = store.append({
  foo: {
    _proto: b5.path,
    hoge: 5,
  }
});
console.assert(b6.get("foo").get("hoge") == 5);
console.assert(b6.get("foo").proto.get("hoge") == 3);

// update deep nested value
const b7 = store.append({
  foo: {
    bar: {
      baz: {
        fiz: 5
      }
    }
  }
});
console.assert(b7.get("foo").get("bar").get("baz").get("fiz") == 5);
b7.get("foo").get("bar").get("baz").set("fiz", 7);
console.assert(b7.get("foo").get("bar").get("baz").get("fiz") == 7);
b7.get("foo").get("bar").get("baz").update({fiz: 8});
console.assert(b7.get("foo").get("bar").get("baz").get("fiz") == 8);


// algebraic data type
// e.g. http://qiita.com/xmeta/items/91dfb24fa87c3a9f5993
const color = store.append({
  _proto: new Path(Value.name),
  _name: "Color",
});
const red = store.append({
  _proto: new Path(color.name),
  _name: "Red",
});
const blue = store.append({
  _proto: new Path(color.name),
  _name: "Green",
});
const green = store.append({
  _proto: new Path(color.name),
  _name: "Blue",
});
const rgb = store.append({
  _proto: new Path(color.name),
  _name: "RGB",
  r: new Path("Number"),
  g: new Path("Number"),
  b: new Path("Number"),
});

// premitive type error
const err1 = store.append({
  _proto: new Path(rgb.name),
  r: 5,
  g: 6,
  b: "invalid",
});
console.assert(err1.proto.equals(store.get("TypeError")));

// required property error
const err2 = store.append({
  _proto: new Path(rgb.name),
  r: 5,
  g: 6,
  // b: "nothing",
});
console.assert(err2.proto.equals(store.get("RequiredPropertyError")));

// namespace
console.assert(store.get("Color"));


// recurcive definition
const list = store.append({
  _name: "List",
  car: new Path("Entity"),
  cdr: new Path("List"),
});
console.assert(store.get("List").get("cdr").equals(store.get("List")));


console.log("all tests succeeded.");
</script>
</head>
<body>
</body>
</html>